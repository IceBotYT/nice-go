{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nice G.O.","text":"<p>Documentation: https://IceBotYT.github.io/nice-go</p> <p>Source Code: https://github.com/IceBotYT/nice-go</p> <p>PyPI: https://pypi.org/project/nice-go/</p> <p>Control various Nice garage door and gate products</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nice-go\n</code></pre>"},{"location":"#development","title":"Development","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.9+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github Pages page automatically as part each release.</p>"},{"location":"#releasing","title":"Releasing","text":"<p>Trigger the Draft release workflow (press Run workflow). This will update the changelog &amp; version and create a GitHub release which is in Draft state.</p> <p>Find the draft release from the GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatting (<code>ruff format</code>), linters (e.g. <code>ruff</code> and <code>mypy</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This project was generated using the wolt-python-package-cookiecutter template.</p>"},{"location":"api_docs/","title":"API documentation","text":"<p>The Nice G.O. API client for Python.</p> <p>To start, see the <code>NiceGOApi</code> class.</p>"},{"location":"api_docs/#nice_go.ApiError","title":"<code>ApiError</code>","text":"<p>               Bases: <code>NiceGOError</code></p> <p>API error.</p> Source code in <code>src/nice_go/_exceptions.py</code> <pre><code>class ApiError(NiceGOError):\n    \"\"\"API error.\"\"\"\n</code></pre>"},{"location":"api_docs/#nice_go.AuthFailedError","title":"<code>AuthFailedError</code>","text":"<p>               Bases: <code>NiceGOError</code></p> <p>Authentication failed. Check your credentials.</p> Source code in <code>src/nice_go/_exceptions.py</code> <pre><code>class AuthFailedError(NiceGOError):\n    \"\"\"Authentication failed. Check your credentials.\"\"\"\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier","title":"<code>Barrier</code>  <code>dataclass</code>","text":"<p>Class representing a barrier.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the barrier.</p> <code>type</code> <code>str</code> <p>The type of the barrier.</p> <code>controlLevel</code> <code>str</code> <p>The control level of the barrier.</p> <code>attr</code> <code>list[dict[str, str]]</code> <p>A list of attributes of the barrier.</p> <code>state</code> <code>BarrierState</code> <p>The state of the barrier.</p> <code>api</code> <code>NiceGOApi</code> <p>The NiceGO API object.</p> <p>Methods:</p> Name Description <code>open</code> <p>Open the barrier.</p> <code>close</code> <p>Close the barrier.</p> <code>light_on</code> <p>Turn on the light of the barrier.</p> <code>light_off</code> <p>Turn off the light of the barrier.</p> <code>get_attr</code> <p>Get the value of an attribute.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>@dataclass\nclass Barrier:\n    \"\"\"Class representing a barrier.\n\n    Attributes:\n        id (str): The ID of the barrier.\n        type (str): The type of the barrier.\n        controlLevel (str): The control level of the barrier.\n        attr (list[dict[str, str]]): A list of attributes of the barrier.\n        state (BarrierState): The state of the barrier.\n        api (NiceGOApi): The NiceGO API object.\n\n    Methods:\n        open: Open the barrier.\n        close: Close the barrier.\n        light_on: Turn on the light of the barrier.\n        light_off: Turn off the light of the barrier.\n        get_attr: Get the value of an attribute.\n    \"\"\"\n\n    id: str\n    type: str\n    controlLevel: str  # noqa: N815\n    attr: list[dict[str, str]]\n    state: BarrierState\n    api: NiceGOApi\n\n    async def open(self) -&gt; bool:\n        \"\"\"Open the barrier.\n\n        Returns:\n            A boolean indicating whether the command was successful.\n        \"\"\"\n        return await self.api.open_barrier(self.id)\n\n    async def close(self) -&gt; bool:\n        \"\"\"Close the barrier.\n\n        Returns:\n            A boolean indicating whether the command was successful.\n        \"\"\"\n        return await self.api.close_barrier(self.id)\n\n    async def light_on(self) -&gt; bool:\n        \"\"\"Turn on the light of the barrier.\n\n        Returns:\n            A boolean indicating whether the command was successful.\n        \"\"\"\n        return await self.api.light_on(self.id)\n\n    async def light_off(self) -&gt; bool:\n        \"\"\"Turn off the light of the barrier.\n\n        Returns:\n            A boolean indicating whether the command was successful.\n        \"\"\"\n        return await self.api.light_off(self.id)\n\n    async def get_attr(self, key: str) -&gt; str:\n        \"\"\"Get the value of an attribute.\n\n        Args:\n            key (str): The key of the attribute.\n\n        Returns:\n            The value of the attribute.\n\n        Raises:\n            KeyError: If the attribute with the given key is not found.\n        \"\"\"\n        attr = next((attr for attr in self.attr if attr[\"key\"] == key), None)\n        if attr is None:\n            msg = f\"Attribute with key {key} not found.\"\n            raise KeyError(msg)\n        return attr[\"value\"]\n\n    async def vacation_mode_on(self) -&gt; None:\n        \"\"\"Turn on vacation mode for the barrier.\"\"\"\n        await self.api.vacation_mode_on(self.id)\n\n    async def vacation_mode_off(self) -&gt; None:\n        \"\"\"Turn off vacation mode for the barrier.\"\"\"\n        await self.api.vacation_mode_off(self.id)\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier.close","title":"<code>close() -&gt; bool</code>  <code>async</code>","text":"<p>Close the barrier.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the command was successful.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>async def close(self) -&gt; bool:\n    \"\"\"Close the barrier.\n\n    Returns:\n        A boolean indicating whether the command was successful.\n    \"\"\"\n    return await self.api.close_barrier(self.id)\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier.get_attr","title":"<code>get_attr(key: str) -&gt; str</code>  <code>async</code>","text":"<p>Get the value of an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The value of the attribute.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the attribute with the given key is not found.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>async def get_attr(self, key: str) -&gt; str:\n    \"\"\"Get the value of an attribute.\n\n    Args:\n        key (str): The key of the attribute.\n\n    Returns:\n        The value of the attribute.\n\n    Raises:\n        KeyError: If the attribute with the given key is not found.\n    \"\"\"\n    attr = next((attr for attr in self.attr if attr[\"key\"] == key), None)\n    if attr is None:\n        msg = f\"Attribute with key {key} not found.\"\n        raise KeyError(msg)\n    return attr[\"value\"]\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier.light_off","title":"<code>light_off() -&gt; bool</code>  <code>async</code>","text":"<p>Turn off the light of the barrier.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the command was successful.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>async def light_off(self) -&gt; bool:\n    \"\"\"Turn off the light of the barrier.\n\n    Returns:\n        A boolean indicating whether the command was successful.\n    \"\"\"\n    return await self.api.light_off(self.id)\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier.light_on","title":"<code>light_on() -&gt; bool</code>  <code>async</code>","text":"<p>Turn on the light of the barrier.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the command was successful.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>async def light_on(self) -&gt; bool:\n    \"\"\"Turn on the light of the barrier.\n\n    Returns:\n        A boolean indicating whether the command was successful.\n    \"\"\"\n    return await self.api.light_on(self.id)\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier.open","title":"<code>open() -&gt; bool</code>  <code>async</code>","text":"<p>Open the barrier.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the command was successful.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>async def open(self) -&gt; bool:\n    \"\"\"Open the barrier.\n\n    Returns:\n        A boolean indicating whether the command was successful.\n    \"\"\"\n    return await self.api.open_barrier(self.id)\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier.vacation_mode_off","title":"<code>vacation_mode_off() -&gt; None</code>  <code>async</code>","text":"<p>Turn off vacation mode for the barrier.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>async def vacation_mode_off(self) -&gt; None:\n    \"\"\"Turn off vacation mode for the barrier.\"\"\"\n    await self.api.vacation_mode_off(self.id)\n</code></pre>"},{"location":"api_docs/#nice_go.Barrier.vacation_mode_on","title":"<code>vacation_mode_on() -&gt; None</code>  <code>async</code>","text":"<p>Turn on vacation mode for the barrier.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>async def vacation_mode_on(self) -&gt; None:\n    \"\"\"Turn on vacation mode for the barrier.\"\"\"\n    await self.api.vacation_mode_on(self.id)\n</code></pre>"},{"location":"api_docs/#nice_go.BarrierState","title":"<code>BarrierState</code>  <code>dataclass</code>","text":"<p>Class representing the state of a barrier.</p> <p>Attributes:</p> Name Type Description <code>deviceId</code> <code>str</code> <p>The device ID of the barrier.</p> <code>reported</code> <code>dict[str, Any]</code> <p>The reported state of the barrier.</p> <code>timestamp</code> <code>str</code> <p>The timestamp of the last update.</p> <code>version</code> <code>str</code> <p>The version of the barrier.</p> <code>connectionState</code> <code>ConnectionState | None</code> <p>The connection state of the barrier.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>@dataclass\nclass BarrierState:\n    \"\"\"Class representing the state of a barrier.\n\n    Attributes:\n        deviceId (str): The device ID of the barrier.\n        reported (dict[str, Any]): The reported state of the barrier.\n        timestamp (str): The timestamp of the last update.\n        version (str): The version of the barrier.\n        connectionState (ConnectionState | None): The connection state of the barrier.\n    \"\"\"\n\n    deviceId: str  # noqa: N815\n    reported: dict[str, Any]\n    timestamp: str\n    version: str\n    connectionState: ConnectionState | None  # noqa: N815\n</code></pre>"},{"location":"api_docs/#nice_go.ConnectionState","title":"<code>ConnectionState</code>  <code>dataclass</code>","text":"<p>Class representing the connection state of a barrier.</p> <p>Attributes:</p> Name Type Description <code>connected</code> <code>bool</code> <p>A boolean indicating whether the barrier is connected.</p> <code>updatedTimestamp</code> <code>datetime</code> <p>The timestamp of the last update.</p> Source code in <code>src/nice_go/_barrier.py</code> <pre><code>@dataclass\nclass ConnectionState:\n    \"\"\"Class representing the connection state of a barrier.\n\n    Attributes:\n        connected (bool): A boolean indicating whether the barrier is connected.\n        updatedTimestamp (datetime): The timestamp of the last update.\n    \"\"\"\n\n    connected: bool\n    updatedTimestamp: datetime  # noqa: N815\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi","title":"<code>NiceGOApi</code>","text":"<p>A class to interact with the Nice G.O. API.</p> <p>This class provides methods to authenticate, connect to the WebSocket API, and interact with barriers.</p> <p>Attributes:</p> Name Type Description <code>id_token</code> <code>str | None</code> <p>The ID token.</p> <p>Methods:</p> Name Description <code>event</code> <p>Decorator to add an event listener.</p> <code>authenticate_refresh</code> <p>Authenticate using a refresh token.</p> <code>authenticate</code> <p>Authenticate using username and password.</p> <code>connect</code> <p>Connect to the WebSocket API.</p> <code>subscribe</code> <p>Subscribe to a receiver.</p> <code>unsubscribe</code> <p>Unsubscribe from a receiver.</p> <code>close</code> <p>Close the connection.</p> <code>get_all_barriers</code> <p>Get all barriers.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>class NiceGOApi:\n    \"\"\"A class to interact with the Nice G.O. API.\n\n    This class provides methods to authenticate, connect to the WebSocket API,\n    and interact with barriers.\n\n    Attributes:\n        id_token (str | None): The ID token.\n\n    Functions:\n        event: Decorator to add an event listener.\n        authenticate_refresh: Authenticate using a refresh token.\n        authenticate: Authenticate using username and password.\n        connect: Connect to the WebSocket API.\n        subscribe: Subscribe to a receiver.\n        unsubscribe: Unsubscribe from a receiver.\n        close: Close the connection.\n        get_all_barriers: Get all barriers.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the NiceGOApi object.\"\"\"\n        self.id_token: str | None = None\n        self._closing_task: asyncio.Task[None] | None = None\n        self._device_ws: WebSocketClient | None = None\n        self._endpoints: dict[str, Any] | None = None\n        self._session: aiohttp.ClientSession | None = None\n        self._event_tasks: set[asyncio.Task[None]] = set()\n        self._events_ws: WebSocketClient | None = None\n        self._device_connected: bool = False\n        self._events_connected: bool = False\n        self._events: dict[str, list[Callable[..., Coroutine[Any, Any, Any]]]] = {}\n\n        self.event(self.on_device_connected)\n        self.event(self.on_events_connected)\n\n    async def on_device_connected(self) -&gt; None:\n        \"\"\"Handle the device connected event.\"\"\"\n        self._device_connected = True\n        if self._device_connected and self._events_connected:\n            # Only dispatch when both feeds are connected\n            self._dispatch(\"connected\")\n\n    async def on_events_connected(self) -&gt; None:\n        \"\"\"Handle the events connected event.\"\"\"\n        self._events_connected = True\n        if self._device_connected and self._events_connected:\n            # Only dispatch when both feeds are connected\n            self._dispatch(\"connected\")\n\n    def event(self, coro: CoroT) -&gt; CoroT:\n        \"\"\"Decorator to add an event listener. Just a wrapper around `listen`.\n\n        Info:\n            This can only decorate coroutine functions.\n\n        Args:\n            coro (CoroT): The coroutine function to decorate.\n\n        Examples:\n            You can use this decorator to add event listeners to the API object.\n            Some events include but are not limited to:\n\n            - `connection_lost`: Triggered when the connection to the WebSocket API is\n                lost.\n            - `connected`: Triggered when the connection to the WebSocket API is\n                established.\n            - `data`: Triggered when data is received from an active subscription.\n                See `subscribe`.\n\n            &gt;&gt;&gt; @api.event\n            ... async def on_data(\n            ...     data: dict[str, Any] | None = None,\n            ... ) -&gt; None:\n            ...     if data is not None:\n            ...         print(data)\n        \"\"\"\n        self.listen(coro.__name__, coro)\n        return coro\n\n    def listen(self, event_name: str, coro: CoroT) -&gt; Callable[[], None]:\n        \"\"\"Add an event listener.\n\n        Args:\n            event_name (str): The name of the event.\n            coro (CoroT): The coroutine to run when the event is dispatched.\n\n        Returns:\n            A function to remove the event listener.\n\n        Examples:\n            You can use this method to add event listeners to the API object.\n            Some events include but are not limited to:\n\n            - `connection_lost`: Triggered when the connection to the WebSocket API is\n                lost.\n            - `connected`: Triggered when the connection to the WebSocket API is\n                established.\n            - `data`: Triggered when data is received from an active subscription.\n                See `subscribe`.\n\n            &gt;&gt;&gt; def on_data(data: dict[str, Any] | None = None) -&gt; None:\n            ...     if data is not None:\n            ...         print(data)\n            ...\n            &gt;&gt;&gt; remove_listener = api.listen(\"data\", on_data)\n        \"\"\"\n        if not asyncio.iscoroutinefunction(coro):\n            msg = \"The decorated function must be a coroutine\"\n            raise TypeError(msg)\n\n        _LOGGER.debug(\"Adding event listener %s\", coro.__name__)\n\n        self._events.setdefault(event_name, []).append(coro)\n        return lambda: self._events[event_name].remove(coro)\n\n    async def _run_event(\n        self,\n        coro: Callable[..., Coroutine[Any, Any, Any]],\n        event_name: str,\n        data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Run an event coroutine. For internal use only.\n\n        Args:\n            coro (Callable[..., Coroutine[Any, Any, Any]]): The coroutine to run.\n            event_name (str): The name of the event.\n            data (dict[str, Any] | None): The data to pass to the event coroutine.\n        \"\"\"\n        kwargs = {}\n        if data is not None:\n            kwargs[\"data\"] = data\n        try:\n            await coro(**kwargs)\n        except asyncio.CancelledError:\n            pass\n        except Exception:\n            _LOGGER.exception(\"Error while handling event %s\", event_name)\n\n    def _schedule_event(\n        self,\n        coro: Callable[..., Coroutine[Any, Any, Any]],\n        event_name: str,\n        data: dict[str, Any] | None,\n    ) -&gt; None:\n        \"\"\"Schedule an event to be dispatched. For internal use only.\n\n        Args:\n            coro (Callable[..., Coroutine[Any, Any, Any]]): The coroutine to schedule.\n            event_name (str): The name of the event.\n            data (dict[str, Any] | None): The data to pass to the event coroutine.\n        \"\"\"\n        wrapped = self._run_event(coro, event_name, data)\n        task = asyncio.create_task(wrapped, name=f\"NiceGO: {event_name}\")\n        self._event_tasks.add(task)  # See RUF006\n        task.add_done_callback(self._event_tasks.discard)\n\n    def _dispatch(self, event: str, data: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Dispatch an event to listeners. For internal use only.\n\n        Args:\n            event (str): The name of the event.\n            data (dict[str, Any] | None): The data to pass to the event coroutine.\n        \"\"\"\n        method = f\"on_{event}\"\n\n        coros = self._events.get(method, [])\n\n        if not coros:\n            _LOGGER.debug(\"No listeners for event %s\", event)\n            return\n\n        _LOGGER.debug(\"Dispatching event %s\", event)\n        for coro in coros:\n            self._schedule_event(coro, method, data)\n\n    async def authenticate_refresh(\n        self,\n        refresh_token: str,\n        session: aiohttp.ClientSession,\n    ) -&gt; None:\n        \"\"\"Authenticate using a previous obtained refresh token.\n\n        Args:\n            refresh_token (str): The refresh token.\n            session (aiohttp.ClientSession): The client session to use.\n\n        Raises:\n            AuthFailedError: If the authentication fails.\n            ApiError: If an API error occurs.\n        \"\"\"\n        self._session = session\n        await self.__authenticate(None, None, refresh_token)\n\n    async def authenticate(\n        self,\n        user_name: str,\n        password: str,\n        session: aiohttp.ClientSession,\n    ) -&gt; str | None:\n        \"\"\"Authenticate using username and password.\n\n        Args:\n            user_name (str): The username.\n            password (str): The password.\n            session (aiohttp.ClientSession): The client session to use.\n\n        Returns:\n            The refresh token.\n\n        Raises:\n            AuthFailedError: If the authentication fails.\n            ApiError: If an API error occurs.\n        \"\"\"\n        self._session = session\n        return await self.__authenticate(user_name, password, None)\n\n    async def __authenticate(\n        self,\n        user_name: str | None,\n        password: str | None,\n        refresh_token: str | None,\n    ) -&gt; str | None:\n        \"\"\"Authenticate using username and password or refresh token.\n\n        Args:\n            user_name (str | None): The username.\n            password (str | None): The password.\n            refresh_token (str | None): The refresh token.\n\n        Returns:\n            The refresh token.\n\n        Raises:\n            AuthFailedError: If the authentication fails.\n            ApiError: If an API error occurs.\n        \"\"\"\n        try:\n            _LOGGER.debug(\"Authenticating\")\n\n            if self._session is None:\n                msg = \"ClientSession not provided\"\n                raise ValueError(msg)\n\n            # Get the endpoints\n            data = await self._session.get(ENDPOINTS_URL)\n            endpoints = await data.json()\n            self._endpoints = endpoints[\"endpoints\"]\n\n            if self._endpoints is None:\n                msg = \"Endpoints not available\"\n                raise ApiError(msg)\n\n            authenticator = AwsCognitoAuthenticator(\n                self._endpoints[\"Config\"][\"Region\"],\n                self._endpoints[\"Config\"][\"ClientId\"],\n                self._endpoints[\"Config\"][\"UserPoolId\"],\n                self._endpoints[\"Config\"][\"IdentityPoolId\"],\n            )\n\n            if user_name and password:\n                token = await asyncio.to_thread(\n                    authenticator.get_new_token,\n                    user_name,\n                    password,\n                )\n            elif refresh_token:\n                token = await asyncio.to_thread(\n                    authenticator.refresh_token,\n                    refresh_token,\n                )\n\n            _LOGGER.debug(\"Authenticated\")\n\n            self.id_token = token.id_token\n        except botocore.exceptions.ClientError as e:\n            _LOGGER.exception(\"Exception while authenticating\")\n            if e.response[\"Error\"][\"Code\"] == \"NotAuthorizedException\":\n                raise AuthFailedError from e\n            raise ApiError from e\n        else:\n            return token.refresh_token\n\n    @property\n    def closed(self) -&gt; bool:\n        \"\"\"Check if the connection is closed.\"\"\"\n        return self._closing_task is not None\n\n    async def _poll_device_ws(self) -&gt; None:\n        \"\"\"Continuously polls the device WebSocket to maintain an active connection.\n        This function will repeatedly call the poll method on the WebSocket if it is\n        initialized.\n\n        Returns:\n            None\n        \"\"\"\n        if self._device_ws is None:\n            return\n        while True:\n            await self._device_ws.poll()\n\n    async def _poll_events_ws(self) -&gt; None:\n        \"\"\"Continuously polls the device WebSocket to maintain an active connection.\n        This function will repeatedly call the poll method on the WebSocket if it is\n        initialized.\n\n        Returns:\n            None\n        \"\"\"\n\n        if self._events_ws is None:\n            return\n        while True:\n            await self._events_ws.poll()\n\n    async def _check_response_errors(self, response: dict[str, Any]) -&gt; None:\n        \"\"\"Checks a GraphQL response for errors, namely for expired tokens.\n\n        Args:\n            response (dict[str, Any]): The response to check.\n\n        Raises:\n            AuthFailedError: If the ID token is expired.\n            ApiError: If an API error occurs.\n\n        Returns:\n            None\n        \"\"\"\n\n        if errors := response.get(\"errors\"):\n            error = errors[0]\n            if error[\"errorType\"] == \"UnauthorizedException\":\n                raise AuthFailedError(error)\n            raise ApiError(error)\n\n    @retry(\n        wait=wait_random_exponential(multiplier=1, min=1, max=10),\n        retry=_RetryIfReconnect()\n        &amp; retry_if_exception_type(\n            (\n                OSError,\n                WebSocketError,\n                aiohttp.ClientError,\n                asyncio.TimeoutError,\n                ReconnectWebSocketError,\n            ),\n        ),\n        reraise=True,\n        before_sleep=before_sleep_log(_LOGGER, logging.DEBUG),\n    )\n    async def connect(self, *, reconnect: bool = True) -&gt; None:\n        \"\"\"Connect to the WebSocket API.\n\n        Warning:\n            No events will be dispatched until you subscribe to a receiver.\n            Typically, you should pass the `organization` attribute of a barrier\n            object to the `subscribe` method to start receiving data. Don't ask me\n            why `organization` specifically, I don't know either.\n\n        Danger:\n            This method will block the event loop until the connection is closed.\n            If you want to run this method in the background, you should run it in a\n            separate thread or process.\n\n        Args:\n            reconnect (bool): Whether to reconnect if the connection is lost.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ApiError: If an API error occurs.\n            WebSocketError: If an error occurs while connecting.\n        \"\"\"\n        try:\n            if self.id_token is None:\n                raise NoAuthError\n\n            if self._endpoints is None:\n                msg = \"Endpoints not available\"\n                raise ApiError(msg)\n\n            if self._session is None:\n                msg = \"ClientSession not provided\"\n                raise ValueError(msg)\n\n            self._reconnect = reconnect\n\n            device_url = self._endpoints[\"GraphQL\"][\"device\"][\"wss\"]\n            events_url = self._endpoints[\"GraphQL\"][\"events\"][\"wss\"]\n\n            _LOGGER.debug(\"Connecting to WebSocket API %s\", device_url)\n\n            self._device_ws = WebSocketClient(client_session=self._session)\n            await self._device_ws.connect(\n                self.id_token,\n                yarl.URL(device_url),\n                \"device\",\n                self._dispatch,\n                yarl.URL(self._endpoints[\"GraphQL\"][\"device\"][\"https\"]).host,\n            )\n            self._events_ws = WebSocketClient(client_session=self._session)\n            await self._events_ws.connect(\n                self.id_token,\n                yarl.URL(events_url),\n                \"events\",\n                self._dispatch,\n                yarl.URL(self._endpoints[\"GraphQL\"][\"events\"][\"https\"]).host,\n            )\n\n            _LOGGER.debug(\"Connected to WebSocket API\")\n\n            device_task = asyncio.create_task(self._poll_device_ws())\n            events_task = asyncio.create_task(self._poll_events_ws())\n\n            with contextlib.suppress(asyncio.CancelledError):\n                done, pending = await asyncio.wait(\n                    [device_task, events_task],\n                    return_when=asyncio.FIRST_EXCEPTION,\n                )\n\n            with contextlib.suppress(UnboundLocalError):\n                if exceptions := [\n                    task.exception() for task in done if task.exception()\n                ]:\n                    for p in pending:\n                        p.cancel()\n                    # Make sure both WS are closed\n                    await self._events_ws.close()\n                    await self._device_ws.close()\n                    raise exceptions[0]  # type: ignore[misc]\n        except (\n            OSError,\n            WebSocketError,\n            aiohttp.ClientError,\n            asyncio.TimeoutError,\n            ReconnectWebSocketError,\n        ) as e:\n            self._dispatch(\"connection_lost\", {\"exception\": e})\n            self._device_connected = False\n            self._events_connected = False\n            if not reconnect:\n                _LOGGER.debug(\"Connection lost, not reconnecting\")\n                await self.close()\n                raise\n\n            if self.closed:\n                return\n\n            _LOGGER.debug(\"Connection lost, retrying...\")\n\n            # Raising triggers retry\n            raise\n\n    async def subscribe(self, receiver: str) -&gt; list[str]:\n        \"\"\"Subscribe to a receiver.\n\n        Args:\n            receiver (str): The receiver to subscribe to.\n\n        Returns:\n            The subscription IDs. You can pass this into the `unsubscribe` method to\n                unsubscribe from the receiver.\n\n        Raises:\n            WebSocketError: If no WebSocket connection is available.\n        \"\"\"\n        if self._device_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n        if self._events_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n\n        _LOGGER.debug(\"Subscribing to receiver %s\", receiver)\n\n        return [\n            await self._device_ws.subscribe(receiver),\n            await self._events_ws.subscribe(receiver),\n        ]\n\n    async def unsubscribe(self, subscription_id: str) -&gt; None:\n        \"\"\"Unsubscribe from a receiver.\n\n        Args:\n            subscription_id (str): The subscription ID to unsubscribe from.\n\n        Raises:\n            WebSocketError: If no WebSocket connection is available\n        \"\"\"\n        if self._device_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n        if self._events_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n\n        _LOGGER.debug(\"Unsubscribing from subscription %s\", subscription_id)\n\n        await self._device_ws.unsubscribe(subscription_id)\n        await self._events_ws.unsubscribe(subscription_id)\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the connection.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n        \"\"\"\n\n        async def _close() -&gt; None:\n            if self._device_ws:\n                await self._device_ws.close()\n            if self._events_ws:\n                await self._events_ws.close()\n\n        _LOGGER.debug(\"Closing connection\")\n\n        self._closing_task = asyncio.create_task(_close())\n        await self._closing_task\n\n    async def get_all_barriers(self) -&gt; list[Barrier]:\n        \"\"\"Get all barriers.\n\n        Returns:\n            A list of all barriers.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Getting all barriers\")\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"get_all_barriers\", None),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Got all barriers\")\n        _LOGGER.debug(\"Data: %s\", data)\n\n        await self._check_response_errors(data)\n\n        barriers = []\n\n        for device in data[\"data\"][\"devicesListAll\"][\"devices\"]:\n            if device[\"state\"][\"connectionState\"] is not None:\n                connection_state = ConnectionState(\n                    device[\"state\"][\"connectionState\"][\"connected\"],\n                    device[\"state\"][\"connectionState\"][\"updatedTimestamp\"],\n                )\n            else:\n                connection_state = None\n            barrier_state = BarrierState(\n                device[\"state\"][\"deviceId\"],\n                json.loads(device[\"state\"][\"reported\"]),\n                device[\"state\"][\"timestamp\"],\n                device[\"state\"][\"version\"],\n                connection_state,\n            )\n            barrier = Barrier(\n                device[\"id\"],\n                device[\"type\"],\n                device[\"controlLevel\"],\n                device[\"attr\"],\n                barrier_state,\n                self,\n            )\n            barriers.append(barrier)\n\n        return barriers\n\n    async def open_barrier(self, barrier_id: str) -&gt; bool:\n        \"\"\"Open a barrier.\n\n        Args:\n            barrier_id (str): The ID of the barrier to open.\n\n        Returns:\n            Whether the barrier was opened successfully.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Opening barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"open_barrier\", {\"barrier_id\": barrier_id}),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Opening barrier response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def close_barrier(self, barrier_id: str) -&gt; bool:\n        \"\"\"Close a barrier.\n\n        Args:\n            barrier_id (str): The ID of the barrier to close.\n\n        Returns:\n            Whether the barrier was closed successfully.\"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Closing barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\n                \"close_barrier\",\n                {\"barrier_id\": barrier_id},\n            ),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Closing barrier response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def light_on(self, barrier_id: str) -&gt; bool:\n        \"\"\"Turn the light on.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn the light on.\n\n        Returns:\n            Whether the light was turned on successfully.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning light on for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"light_on\", {\"barrier_id\": barrier_id}),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Turning light on response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def light_off(self, barrier_id: str) -&gt; bool:\n        \"\"\"Turn the light off.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn the light off.\n\n        Returns:\n            Whether the light was turned off successfully.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning light off for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"light_off\", {\"barrier_id\": barrier_id}),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Turning light off response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def vacation_mode_on(self, barrier_id: str) -&gt; None:\n        \"\"\"Turn vacation mode on.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn vacation mode on.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning vacation mode on for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\n                \"vacation_mode_on\",\n                {\"barrier_id\": barrier_id},\n            ),\n        )\n        await response.json()\n\n    async def vacation_mode_off(self, barrier_id: str) -&gt; None:\n        \"\"\"Turn vacation mode off.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn vacation mode off.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning vacation mode off for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\n                \"vacation_mode_off\",\n                {\"barrier_id\": barrier_id},\n            ),\n        )\n        await response.json()\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.closed","title":"<code>closed: bool</code>  <code>property</code>","text":"<p>Check if the connection is closed.</p>"},{"location":"api_docs/#nice_go.NiceGOApi.__authenticate","title":"<code>__authenticate(user_name: str | None, password: str | None, refresh_token: str | None) -&gt; str | None</code>  <code>async</code>","text":"<p>Authenticate using username and password or refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str | None</code> <p>The username.</p> required <code>password</code> <code>str | None</code> <p>The password.</p> required <code>refresh_token</code> <code>str | None</code> <p>The refresh token.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The refresh token.</p> <p>Raises:</p> Type Description <code>AuthFailedError</code> <p>If the authentication fails.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def __authenticate(\n    self,\n    user_name: str | None,\n    password: str | None,\n    refresh_token: str | None,\n) -&gt; str | None:\n    \"\"\"Authenticate using username and password or refresh token.\n\n    Args:\n        user_name (str | None): The username.\n        password (str | None): The password.\n        refresh_token (str | None): The refresh token.\n\n    Returns:\n        The refresh token.\n\n    Raises:\n        AuthFailedError: If the authentication fails.\n        ApiError: If an API error occurs.\n    \"\"\"\n    try:\n        _LOGGER.debug(\"Authenticating\")\n\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n\n        # Get the endpoints\n        data = await self._session.get(ENDPOINTS_URL)\n        endpoints = await data.json()\n        self._endpoints = endpoints[\"endpoints\"]\n\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        authenticator = AwsCognitoAuthenticator(\n            self._endpoints[\"Config\"][\"Region\"],\n            self._endpoints[\"Config\"][\"ClientId\"],\n            self._endpoints[\"Config\"][\"UserPoolId\"],\n            self._endpoints[\"Config\"][\"IdentityPoolId\"],\n        )\n\n        if user_name and password:\n            token = await asyncio.to_thread(\n                authenticator.get_new_token,\n                user_name,\n                password,\n            )\n        elif refresh_token:\n            token = await asyncio.to_thread(\n                authenticator.refresh_token,\n                refresh_token,\n            )\n\n        _LOGGER.debug(\"Authenticated\")\n\n        self.id_token = token.id_token\n    except botocore.exceptions.ClientError as e:\n        _LOGGER.exception(\"Exception while authenticating\")\n        if e.response[\"Error\"][\"Code\"] == \"NotAuthorizedException\":\n            raise AuthFailedError from e\n        raise ApiError from e\n    else:\n        return token.refresh_token\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the NiceGOApi object.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the NiceGOApi object.\"\"\"\n    self.id_token: str | None = None\n    self._closing_task: asyncio.Task[None] | None = None\n    self._device_ws: WebSocketClient | None = None\n    self._endpoints: dict[str, Any] | None = None\n    self._session: aiohttp.ClientSession | None = None\n    self._event_tasks: set[asyncio.Task[None]] = set()\n    self._events_ws: WebSocketClient | None = None\n    self._device_connected: bool = False\n    self._events_connected: bool = False\n    self._events: dict[str, list[Callable[..., Coroutine[Any, Any, Any]]]] = {}\n\n    self.event(self.on_device_connected)\n    self.event(self.on_events_connected)\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.authenticate","title":"<code>authenticate(user_name: str, password: str, session: aiohttp.ClientSession) -&gt; str | None</code>  <code>async</code>","text":"<p>Authenticate using username and password.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> <p>The username.</p> required <code>password</code> <code>str</code> <p>The password.</p> required <code>session</code> <code>ClientSession</code> <p>The client session to use.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The refresh token.</p> <p>Raises:</p> Type Description <code>AuthFailedError</code> <p>If the authentication fails.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def authenticate(\n    self,\n    user_name: str,\n    password: str,\n    session: aiohttp.ClientSession,\n) -&gt; str | None:\n    \"\"\"Authenticate using username and password.\n\n    Args:\n        user_name (str): The username.\n        password (str): The password.\n        session (aiohttp.ClientSession): The client session to use.\n\n    Returns:\n        The refresh token.\n\n    Raises:\n        AuthFailedError: If the authentication fails.\n        ApiError: If an API error occurs.\n    \"\"\"\n    self._session = session\n    return await self.__authenticate(user_name, password, None)\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.authenticate_refresh","title":"<code>authenticate_refresh(refresh_token: str, session: aiohttp.ClientSession) -&gt; None</code>  <code>async</code>","text":"<p>Authenticate using a previous obtained refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>The refresh token.</p> required <code>session</code> <code>ClientSession</code> <p>The client session to use.</p> required <p>Raises:</p> Type Description <code>AuthFailedError</code> <p>If the authentication fails.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def authenticate_refresh(\n    self,\n    refresh_token: str,\n    session: aiohttp.ClientSession,\n) -&gt; None:\n    \"\"\"Authenticate using a previous obtained refresh token.\n\n    Args:\n        refresh_token (str): The refresh token.\n        session (aiohttp.ClientSession): The client session to use.\n\n    Raises:\n        AuthFailedError: If the authentication fails.\n        ApiError: If an API error occurs.\n    \"\"\"\n    self._session = session\n    await self.__authenticate(None, None, refresh_token)\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.close","title":"<code>close() -&gt; None</code>  <code>async</code>","text":"<p>Close the connection.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the connection.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n    \"\"\"\n\n    async def _close() -&gt; None:\n        if self._device_ws:\n            await self._device_ws.close()\n        if self._events_ws:\n            await self._events_ws.close()\n\n    _LOGGER.debug(\"Closing connection\")\n\n    self._closing_task = asyncio.create_task(_close())\n    await self._closing_task\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.close_barrier","title":"<code>close_barrier(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Close a barrier.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to close.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the barrier was closed successfully.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def close_barrier(self, barrier_id: str) -&gt; bool:\n    \"\"\"Close a barrier.\n\n    Args:\n        barrier_id (str): The ID of the barrier to close.\n\n    Returns:\n        Whether the barrier was closed successfully.\"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Closing barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\n            \"close_barrier\",\n            {\"barrier_id\": barrier_id},\n        ),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Closing barrier response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.connect","title":"<code>connect(*, reconnect: bool = True) -&gt; None</code>  <code>async</code>","text":"<p>Connect to the WebSocket API.</p> Warning <p>No events will be dispatched until you subscribe to a receiver. Typically, you should pass the <code>organization</code> attribute of a barrier object to the <code>subscribe</code> method to start receiving data. Don't ask me why <code>organization</code> specifically, I don't know either.</p> Danger <p>This method will block the event loop until the connection is closed. If you want to run this method in the background, you should run it in a separate thread or process.</p> <p>Parameters:</p> Name Type Description Default <code>reconnect</code> <code>bool</code> <p>Whether to reconnect if the connection is lost.</p> <code>True</code> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> <code>WebSocketError</code> <p>If an error occurs while connecting.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>@retry(\n    wait=wait_random_exponential(multiplier=1, min=1, max=10),\n    retry=_RetryIfReconnect()\n    &amp; retry_if_exception_type(\n        (\n            OSError,\n            WebSocketError,\n            aiohttp.ClientError,\n            asyncio.TimeoutError,\n            ReconnectWebSocketError,\n        ),\n    ),\n    reraise=True,\n    before_sleep=before_sleep_log(_LOGGER, logging.DEBUG),\n)\nasync def connect(self, *, reconnect: bool = True) -&gt; None:\n    \"\"\"Connect to the WebSocket API.\n\n    Warning:\n        No events will be dispatched until you subscribe to a receiver.\n        Typically, you should pass the `organization` attribute of a barrier\n        object to the `subscribe` method to start receiving data. Don't ask me\n        why `organization` specifically, I don't know either.\n\n    Danger:\n        This method will block the event loop until the connection is closed.\n        If you want to run this method in the background, you should run it in a\n        separate thread or process.\n\n    Args:\n        reconnect (bool): Whether to reconnect if the connection is lost.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ApiError: If an API error occurs.\n        WebSocketError: If an error occurs while connecting.\n    \"\"\"\n    try:\n        if self.id_token is None:\n            raise NoAuthError\n\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n\n        self._reconnect = reconnect\n\n        device_url = self._endpoints[\"GraphQL\"][\"device\"][\"wss\"]\n        events_url = self._endpoints[\"GraphQL\"][\"events\"][\"wss\"]\n\n        _LOGGER.debug(\"Connecting to WebSocket API %s\", device_url)\n\n        self._device_ws = WebSocketClient(client_session=self._session)\n        await self._device_ws.connect(\n            self.id_token,\n            yarl.URL(device_url),\n            \"device\",\n            self._dispatch,\n            yarl.URL(self._endpoints[\"GraphQL\"][\"device\"][\"https\"]).host,\n        )\n        self._events_ws = WebSocketClient(client_session=self._session)\n        await self._events_ws.connect(\n            self.id_token,\n            yarl.URL(events_url),\n            \"events\",\n            self._dispatch,\n            yarl.URL(self._endpoints[\"GraphQL\"][\"events\"][\"https\"]).host,\n        )\n\n        _LOGGER.debug(\"Connected to WebSocket API\")\n\n        device_task = asyncio.create_task(self._poll_device_ws())\n        events_task = asyncio.create_task(self._poll_events_ws())\n\n        with contextlib.suppress(asyncio.CancelledError):\n            done, pending = await asyncio.wait(\n                [device_task, events_task],\n                return_when=asyncio.FIRST_EXCEPTION,\n            )\n\n        with contextlib.suppress(UnboundLocalError):\n            if exceptions := [\n                task.exception() for task in done if task.exception()\n            ]:\n                for p in pending:\n                    p.cancel()\n                # Make sure both WS are closed\n                await self._events_ws.close()\n                await self._device_ws.close()\n                raise exceptions[0]  # type: ignore[misc]\n    except (\n        OSError,\n        WebSocketError,\n        aiohttp.ClientError,\n        asyncio.TimeoutError,\n        ReconnectWebSocketError,\n    ) as e:\n        self._dispatch(\"connection_lost\", {\"exception\": e})\n        self._device_connected = False\n        self._events_connected = False\n        if not reconnect:\n            _LOGGER.debug(\"Connection lost, not reconnecting\")\n            await self.close()\n            raise\n\n        if self.closed:\n            return\n\n        _LOGGER.debug(\"Connection lost, retrying...\")\n\n        # Raising triggers retry\n        raise\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.event","title":"<code>event(coro: CoroT) -&gt; CoroT</code>","text":"<p>Decorator to add an event listener. Just a wrapper around <code>listen</code>.</p> Info <p>This can only decorate coroutine functions.</p> <p>Parameters:</p> Name Type Description Default <code>coro</code> <code>CoroT</code> <p>The coroutine function to decorate.</p> required <p>Examples:</p> <p>You can use this decorator to add event listeners to the API object. Some events include but are not limited to:</p> <ul> <li><code>connection_lost</code>: Triggered when the connection to the WebSocket API is     lost.</li> <li><code>connected</code>: Triggered when the connection to the WebSocket API is     established.</li> <li><code>data</code>: Triggered when data is received from an active subscription.     See <code>subscribe</code>.</li> </ul> <pre><code>&gt;&gt;&gt; @api.event\n... async def on_data(\n...     data: dict[str, Any] | None = None,\n... ) -&gt; None:\n...     if data is not None:\n...         print(data)\n</code></pre> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>def event(self, coro: CoroT) -&gt; CoroT:\n    \"\"\"Decorator to add an event listener. Just a wrapper around `listen`.\n\n    Info:\n        This can only decorate coroutine functions.\n\n    Args:\n        coro (CoroT): The coroutine function to decorate.\n\n    Examples:\n        You can use this decorator to add event listeners to the API object.\n        Some events include but are not limited to:\n\n        - `connection_lost`: Triggered when the connection to the WebSocket API is\n            lost.\n        - `connected`: Triggered when the connection to the WebSocket API is\n            established.\n        - `data`: Triggered when data is received from an active subscription.\n            See `subscribe`.\n\n        &gt;&gt;&gt; @api.event\n        ... async def on_data(\n        ...     data: dict[str, Any] | None = None,\n        ... ) -&gt; None:\n        ...     if data is not None:\n        ...         print(data)\n    \"\"\"\n    self.listen(coro.__name__, coro)\n    return coro\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.get_all_barriers","title":"<code>get_all_barriers() -&gt; list[Barrier]</code>  <code>async</code>","text":"<p>Get all barriers.</p> <p>Returns:</p> Type Description <code>list[Barrier]</code> <p>A list of all barriers.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def get_all_barriers(self) -&gt; list[Barrier]:\n    \"\"\"Get all barriers.\n\n    Returns:\n        A list of all barriers.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Getting all barriers\")\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"get_all_barriers\", None),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Got all barriers\")\n    _LOGGER.debug(\"Data: %s\", data)\n\n    await self._check_response_errors(data)\n\n    barriers = []\n\n    for device in data[\"data\"][\"devicesListAll\"][\"devices\"]:\n        if device[\"state\"][\"connectionState\"] is not None:\n            connection_state = ConnectionState(\n                device[\"state\"][\"connectionState\"][\"connected\"],\n                device[\"state\"][\"connectionState\"][\"updatedTimestamp\"],\n            )\n        else:\n            connection_state = None\n        barrier_state = BarrierState(\n            device[\"state\"][\"deviceId\"],\n            json.loads(device[\"state\"][\"reported\"]),\n            device[\"state\"][\"timestamp\"],\n            device[\"state\"][\"version\"],\n            connection_state,\n        )\n        barrier = Barrier(\n            device[\"id\"],\n            device[\"type\"],\n            device[\"controlLevel\"],\n            device[\"attr\"],\n            barrier_state,\n            self,\n        )\n        barriers.append(barrier)\n\n    return barriers\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.light_off","title":"<code>light_off(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Turn the light off.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn the light off.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the light was turned off successfully.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def light_off(self, barrier_id: str) -&gt; bool:\n    \"\"\"Turn the light off.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn the light off.\n\n    Returns:\n        Whether the light was turned off successfully.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning light off for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"light_off\", {\"barrier_id\": barrier_id}),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Turning light off response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.light_on","title":"<code>light_on(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Turn the light on.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn the light on.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the light was turned on successfully.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def light_on(self, barrier_id: str) -&gt; bool:\n    \"\"\"Turn the light on.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn the light on.\n\n    Returns:\n        Whether the light was turned on successfully.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning light on for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"light_on\", {\"barrier_id\": barrier_id}),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Turning light on response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.listen","title":"<code>listen(event_name: str, coro: CoroT) -&gt; Callable[[], None]</code>","text":"<p>Add an event listener.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The name of the event.</p> required <code>coro</code> <code>CoroT</code> <p>The coroutine to run when the event is dispatched.</p> required <p>Returns:</p> Type Description <code>Callable[[], None]</code> <p>A function to remove the event listener.</p> <p>Examples:</p> <p>You can use this method to add event listeners to the API object. Some events include but are not limited to:</p> <ul> <li><code>connection_lost</code>: Triggered when the connection to the WebSocket API is     lost.</li> <li><code>connected</code>: Triggered when the connection to the WebSocket API is     established.</li> <li><code>data</code>: Triggered when data is received from an active subscription.     See <code>subscribe</code>.</li> </ul> <pre><code>&gt;&gt;&gt; def on_data(data: dict[str, Any] | None = None) -&gt; None:\n...     if data is not None:\n...         print(data)\n...\n&gt;&gt;&gt; remove_listener = api.listen(\"data\", on_data)\n</code></pre> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>def listen(self, event_name: str, coro: CoroT) -&gt; Callable[[], None]:\n    \"\"\"Add an event listener.\n\n    Args:\n        event_name (str): The name of the event.\n        coro (CoroT): The coroutine to run when the event is dispatched.\n\n    Returns:\n        A function to remove the event listener.\n\n    Examples:\n        You can use this method to add event listeners to the API object.\n        Some events include but are not limited to:\n\n        - `connection_lost`: Triggered when the connection to the WebSocket API is\n            lost.\n        - `connected`: Triggered when the connection to the WebSocket API is\n            established.\n        - `data`: Triggered when data is received from an active subscription.\n            See `subscribe`.\n\n        &gt;&gt;&gt; def on_data(data: dict[str, Any] | None = None) -&gt; None:\n        ...     if data is not None:\n        ...         print(data)\n        ...\n        &gt;&gt;&gt; remove_listener = api.listen(\"data\", on_data)\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coro):\n        msg = \"The decorated function must be a coroutine\"\n        raise TypeError(msg)\n\n    _LOGGER.debug(\"Adding event listener %s\", coro.__name__)\n\n    self._events.setdefault(event_name, []).append(coro)\n    return lambda: self._events[event_name].remove(coro)\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.on_device_connected","title":"<code>on_device_connected() -&gt; None</code>  <code>async</code>","text":"<p>Handle the device connected event.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def on_device_connected(self) -&gt; None:\n    \"\"\"Handle the device connected event.\"\"\"\n    self._device_connected = True\n    if self._device_connected and self._events_connected:\n        # Only dispatch when both feeds are connected\n        self._dispatch(\"connected\")\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.on_events_connected","title":"<code>on_events_connected() -&gt; None</code>  <code>async</code>","text":"<p>Handle the events connected event.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def on_events_connected(self) -&gt; None:\n    \"\"\"Handle the events connected event.\"\"\"\n    self._events_connected = True\n    if self._device_connected and self._events_connected:\n        # Only dispatch when both feeds are connected\n        self._dispatch(\"connected\")\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.open_barrier","title":"<code>open_barrier(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Open a barrier.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to open.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the barrier was opened successfully.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def open_barrier(self, barrier_id: str) -&gt; bool:\n    \"\"\"Open a barrier.\n\n    Args:\n        barrier_id (str): The ID of the barrier to open.\n\n    Returns:\n        Whether the barrier was opened successfully.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Opening barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"open_barrier\", {\"barrier_id\": barrier_id}),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Opening barrier response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.subscribe","title":"<code>subscribe(receiver: str) -&gt; list[str]</code>  <code>async</code>","text":"<p>Subscribe to a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>The receiver to subscribe to.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The subscription IDs. You can pass this into the <code>unsubscribe</code> method to unsubscribe from the receiver.</p> <p>Raises:</p> Type Description <code>WebSocketError</code> <p>If no WebSocket connection is available.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def subscribe(self, receiver: str) -&gt; list[str]:\n    \"\"\"Subscribe to a receiver.\n\n    Args:\n        receiver (str): The receiver to subscribe to.\n\n    Returns:\n        The subscription IDs. You can pass this into the `unsubscribe` method to\n            unsubscribe from the receiver.\n\n    Raises:\n        WebSocketError: If no WebSocket connection is available.\n    \"\"\"\n    if self._device_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n    if self._events_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n\n    _LOGGER.debug(\"Subscribing to receiver %s\", receiver)\n\n    return [\n        await self._device_ws.subscribe(receiver),\n        await self._events_ws.subscribe(receiver),\n    ]\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.unsubscribe","title":"<code>unsubscribe(subscription_id: str) -&gt; None</code>  <code>async</code>","text":"<p>Unsubscribe from a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>subscription_id</code> <code>str</code> <p>The subscription ID to unsubscribe from.</p> required <p>Raises:</p> Type Description <code>WebSocketError</code> <p>If no WebSocket connection is available</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def unsubscribe(self, subscription_id: str) -&gt; None:\n    \"\"\"Unsubscribe from a receiver.\n\n    Args:\n        subscription_id (str): The subscription ID to unsubscribe from.\n\n    Raises:\n        WebSocketError: If no WebSocket connection is available\n    \"\"\"\n    if self._device_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n    if self._events_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n\n    _LOGGER.debug(\"Unsubscribing from subscription %s\", subscription_id)\n\n    await self._device_ws.unsubscribe(subscription_id)\n    await self._events_ws.unsubscribe(subscription_id)\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.vacation_mode_off","title":"<code>vacation_mode_off(barrier_id: str) -&gt; None</code>  <code>async</code>","text":"<p>Turn vacation mode off.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn vacation mode off.</p> required <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def vacation_mode_off(self, barrier_id: str) -&gt; None:\n    \"\"\"Turn vacation mode off.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn vacation mode off.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning vacation mode off for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\n            \"vacation_mode_off\",\n            {\"barrier_id\": barrier_id},\n        ),\n    )\n    await response.json()\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOApi.vacation_mode_on","title":"<code>vacation_mode_on(barrier_id: str) -&gt; None</code>  <code>async</code>","text":"<p>Turn vacation mode on.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn vacation mode on.</p> required <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def vacation_mode_on(self, barrier_id: str) -&gt; None:\n    \"\"\"Turn vacation mode on.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn vacation mode on.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning vacation mode on for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\n            \"vacation_mode_on\",\n            {\"barrier_id\": barrier_id},\n        ),\n    )\n    await response.json()\n</code></pre>"},{"location":"api_docs/#nice_go.NiceGOError","title":"<code>NiceGOError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Nice G.O. API.</p> Source code in <code>src/nice_go/_exceptions.py</code> <pre><code>class NiceGOError(Exception):\n    \"\"\"Base exception for Nice G.O. API.\"\"\"\n</code></pre>"},{"location":"api_docs/#nice_go.NoAuthError","title":"<code>NoAuthError</code>","text":"<p>               Bases: <code>NiceGOError</code></p> <p>Not authenticated exception.</p> Source code in <code>src/nice_go/_exceptions.py</code> <pre><code>class NoAuthError(NiceGOError):\n    \"\"\"Not authenticated exception.\"\"\"\n</code></pre>"},{"location":"api_docs/#nice_go.WebSocketError","title":"<code>WebSocketError</code>","text":"<p>               Bases: <code>NiceGOError</code></p> <p>WebSocket error.</p> Source code in <code>src/nice_go/_exceptions.py</code> <pre><code>class WebSocketError(NiceGOError):\n    \"\"\"WebSocket error.\"\"\"\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api","title":"<code>nice_go_api</code>","text":"<p>Parses data from the Nice G.O. API.</p> <p>This module provides a class to interact with the Nice G.O. API. It allows the user to authenticate, connect to the WebSocket API, and interact with barriers.</p> <p>Classes:</p> Name Description <code>NiceGOApi</code> <p>A class to interact with the Nice G.O. API.</p>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi","title":"<code>NiceGOApi</code>","text":"<p>A class to interact with the Nice G.O. API.</p> <p>This class provides methods to authenticate, connect to the WebSocket API, and interact with barriers.</p> <p>Attributes:</p> Name Type Description <code>id_token</code> <code>str | None</code> <p>The ID token.</p> <p>Methods:</p> Name Description <code>event</code> <p>Decorator to add an event listener.</p> <code>authenticate_refresh</code> <p>Authenticate using a refresh token.</p> <code>authenticate</code> <p>Authenticate using username and password.</p> <code>connect</code> <p>Connect to the WebSocket API.</p> <code>subscribe</code> <p>Subscribe to a receiver.</p> <code>unsubscribe</code> <p>Unsubscribe from a receiver.</p> <code>close</code> <p>Close the connection.</p> <code>get_all_barriers</code> <p>Get all barriers.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>class NiceGOApi:\n    \"\"\"A class to interact with the Nice G.O. API.\n\n    This class provides methods to authenticate, connect to the WebSocket API,\n    and interact with barriers.\n\n    Attributes:\n        id_token (str | None): The ID token.\n\n    Functions:\n        event: Decorator to add an event listener.\n        authenticate_refresh: Authenticate using a refresh token.\n        authenticate: Authenticate using username and password.\n        connect: Connect to the WebSocket API.\n        subscribe: Subscribe to a receiver.\n        unsubscribe: Unsubscribe from a receiver.\n        close: Close the connection.\n        get_all_barriers: Get all barriers.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the NiceGOApi object.\"\"\"\n        self.id_token: str | None = None\n        self._closing_task: asyncio.Task[None] | None = None\n        self._device_ws: WebSocketClient | None = None\n        self._endpoints: dict[str, Any] | None = None\n        self._session: aiohttp.ClientSession | None = None\n        self._event_tasks: set[asyncio.Task[None]] = set()\n        self._events_ws: WebSocketClient | None = None\n        self._device_connected: bool = False\n        self._events_connected: bool = False\n        self._events: dict[str, list[Callable[..., Coroutine[Any, Any, Any]]]] = {}\n\n        self.event(self.on_device_connected)\n        self.event(self.on_events_connected)\n\n    async def on_device_connected(self) -&gt; None:\n        \"\"\"Handle the device connected event.\"\"\"\n        self._device_connected = True\n        if self._device_connected and self._events_connected:\n            # Only dispatch when both feeds are connected\n            self._dispatch(\"connected\")\n\n    async def on_events_connected(self) -&gt; None:\n        \"\"\"Handle the events connected event.\"\"\"\n        self._events_connected = True\n        if self._device_connected and self._events_connected:\n            # Only dispatch when both feeds are connected\n            self._dispatch(\"connected\")\n\n    def event(self, coro: CoroT) -&gt; CoroT:\n        \"\"\"Decorator to add an event listener. Just a wrapper around `listen`.\n\n        Info:\n            This can only decorate coroutine functions.\n\n        Args:\n            coro (CoroT): The coroutine function to decorate.\n\n        Examples:\n            You can use this decorator to add event listeners to the API object.\n            Some events include but are not limited to:\n\n            - `connection_lost`: Triggered when the connection to the WebSocket API is\n                lost.\n            - `connected`: Triggered when the connection to the WebSocket API is\n                established.\n            - `data`: Triggered when data is received from an active subscription.\n                See `subscribe`.\n\n            &gt;&gt;&gt; @api.event\n            ... async def on_data(\n            ...     data: dict[str, Any] | None = None,\n            ... ) -&gt; None:\n            ...     if data is not None:\n            ...         print(data)\n        \"\"\"\n        self.listen(coro.__name__, coro)\n        return coro\n\n    def listen(self, event_name: str, coro: CoroT) -&gt; Callable[[], None]:\n        \"\"\"Add an event listener.\n\n        Args:\n            event_name (str): The name of the event.\n            coro (CoroT): The coroutine to run when the event is dispatched.\n\n        Returns:\n            A function to remove the event listener.\n\n        Examples:\n            You can use this method to add event listeners to the API object.\n            Some events include but are not limited to:\n\n            - `connection_lost`: Triggered when the connection to the WebSocket API is\n                lost.\n            - `connected`: Triggered when the connection to the WebSocket API is\n                established.\n            - `data`: Triggered when data is received from an active subscription.\n                See `subscribe`.\n\n            &gt;&gt;&gt; def on_data(data: dict[str, Any] | None = None) -&gt; None:\n            ...     if data is not None:\n            ...         print(data)\n            ...\n            &gt;&gt;&gt; remove_listener = api.listen(\"data\", on_data)\n        \"\"\"\n        if not asyncio.iscoroutinefunction(coro):\n            msg = \"The decorated function must be a coroutine\"\n            raise TypeError(msg)\n\n        _LOGGER.debug(\"Adding event listener %s\", coro.__name__)\n\n        self._events.setdefault(event_name, []).append(coro)\n        return lambda: self._events[event_name].remove(coro)\n\n    async def _run_event(\n        self,\n        coro: Callable[..., Coroutine[Any, Any, Any]],\n        event_name: str,\n        data: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Run an event coroutine. For internal use only.\n\n        Args:\n            coro (Callable[..., Coroutine[Any, Any, Any]]): The coroutine to run.\n            event_name (str): The name of the event.\n            data (dict[str, Any] | None): The data to pass to the event coroutine.\n        \"\"\"\n        kwargs = {}\n        if data is not None:\n            kwargs[\"data\"] = data\n        try:\n            await coro(**kwargs)\n        except asyncio.CancelledError:\n            pass\n        except Exception:\n            _LOGGER.exception(\"Error while handling event %s\", event_name)\n\n    def _schedule_event(\n        self,\n        coro: Callable[..., Coroutine[Any, Any, Any]],\n        event_name: str,\n        data: dict[str, Any] | None,\n    ) -&gt; None:\n        \"\"\"Schedule an event to be dispatched. For internal use only.\n\n        Args:\n            coro (Callable[..., Coroutine[Any, Any, Any]]): The coroutine to schedule.\n            event_name (str): The name of the event.\n            data (dict[str, Any] | None): The data to pass to the event coroutine.\n        \"\"\"\n        wrapped = self._run_event(coro, event_name, data)\n        task = asyncio.create_task(wrapped, name=f\"NiceGO: {event_name}\")\n        self._event_tasks.add(task)  # See RUF006\n        task.add_done_callback(self._event_tasks.discard)\n\n    def _dispatch(self, event: str, data: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Dispatch an event to listeners. For internal use only.\n\n        Args:\n            event (str): The name of the event.\n            data (dict[str, Any] | None): The data to pass to the event coroutine.\n        \"\"\"\n        method = f\"on_{event}\"\n\n        coros = self._events.get(method, [])\n\n        if not coros:\n            _LOGGER.debug(\"No listeners for event %s\", event)\n            return\n\n        _LOGGER.debug(\"Dispatching event %s\", event)\n        for coro in coros:\n            self._schedule_event(coro, method, data)\n\n    async def authenticate_refresh(\n        self,\n        refresh_token: str,\n        session: aiohttp.ClientSession,\n    ) -&gt; None:\n        \"\"\"Authenticate using a previous obtained refresh token.\n\n        Args:\n            refresh_token (str): The refresh token.\n            session (aiohttp.ClientSession): The client session to use.\n\n        Raises:\n            AuthFailedError: If the authentication fails.\n            ApiError: If an API error occurs.\n        \"\"\"\n        self._session = session\n        await self.__authenticate(None, None, refresh_token)\n\n    async def authenticate(\n        self,\n        user_name: str,\n        password: str,\n        session: aiohttp.ClientSession,\n    ) -&gt; str | None:\n        \"\"\"Authenticate using username and password.\n\n        Args:\n            user_name (str): The username.\n            password (str): The password.\n            session (aiohttp.ClientSession): The client session to use.\n\n        Returns:\n            The refresh token.\n\n        Raises:\n            AuthFailedError: If the authentication fails.\n            ApiError: If an API error occurs.\n        \"\"\"\n        self._session = session\n        return await self.__authenticate(user_name, password, None)\n\n    async def __authenticate(\n        self,\n        user_name: str | None,\n        password: str | None,\n        refresh_token: str | None,\n    ) -&gt; str | None:\n        \"\"\"Authenticate using username and password or refresh token.\n\n        Args:\n            user_name (str | None): The username.\n            password (str | None): The password.\n            refresh_token (str | None): The refresh token.\n\n        Returns:\n            The refresh token.\n\n        Raises:\n            AuthFailedError: If the authentication fails.\n            ApiError: If an API error occurs.\n        \"\"\"\n        try:\n            _LOGGER.debug(\"Authenticating\")\n\n            if self._session is None:\n                msg = \"ClientSession not provided\"\n                raise ValueError(msg)\n\n            # Get the endpoints\n            data = await self._session.get(ENDPOINTS_URL)\n            endpoints = await data.json()\n            self._endpoints = endpoints[\"endpoints\"]\n\n            if self._endpoints is None:\n                msg = \"Endpoints not available\"\n                raise ApiError(msg)\n\n            authenticator = AwsCognitoAuthenticator(\n                self._endpoints[\"Config\"][\"Region\"],\n                self._endpoints[\"Config\"][\"ClientId\"],\n                self._endpoints[\"Config\"][\"UserPoolId\"],\n                self._endpoints[\"Config\"][\"IdentityPoolId\"],\n            )\n\n            if user_name and password:\n                token = await asyncio.to_thread(\n                    authenticator.get_new_token,\n                    user_name,\n                    password,\n                )\n            elif refresh_token:\n                token = await asyncio.to_thread(\n                    authenticator.refresh_token,\n                    refresh_token,\n                )\n\n            _LOGGER.debug(\"Authenticated\")\n\n            self.id_token = token.id_token\n        except botocore.exceptions.ClientError as e:\n            _LOGGER.exception(\"Exception while authenticating\")\n            if e.response[\"Error\"][\"Code\"] == \"NotAuthorizedException\":\n                raise AuthFailedError from e\n            raise ApiError from e\n        else:\n            return token.refresh_token\n\n    @property\n    def closed(self) -&gt; bool:\n        \"\"\"Check if the connection is closed.\"\"\"\n        return self._closing_task is not None\n\n    async def _poll_device_ws(self) -&gt; None:\n        \"\"\"Continuously polls the device WebSocket to maintain an active connection.\n        This function will repeatedly call the poll method on the WebSocket if it is\n        initialized.\n\n        Returns:\n            None\n        \"\"\"\n        if self._device_ws is None:\n            return\n        while True:\n            await self._device_ws.poll()\n\n    async def _poll_events_ws(self) -&gt; None:\n        \"\"\"Continuously polls the device WebSocket to maintain an active connection.\n        This function will repeatedly call the poll method on the WebSocket if it is\n        initialized.\n\n        Returns:\n            None\n        \"\"\"\n\n        if self._events_ws is None:\n            return\n        while True:\n            await self._events_ws.poll()\n\n    async def _check_response_errors(self, response: dict[str, Any]) -&gt; None:\n        \"\"\"Checks a GraphQL response for errors, namely for expired tokens.\n\n        Args:\n            response (dict[str, Any]): The response to check.\n\n        Raises:\n            AuthFailedError: If the ID token is expired.\n            ApiError: If an API error occurs.\n\n        Returns:\n            None\n        \"\"\"\n\n        if errors := response.get(\"errors\"):\n            error = errors[0]\n            if error[\"errorType\"] == \"UnauthorizedException\":\n                raise AuthFailedError(error)\n            raise ApiError(error)\n\n    @retry(\n        wait=wait_random_exponential(multiplier=1, min=1, max=10),\n        retry=_RetryIfReconnect()\n        &amp; retry_if_exception_type(\n            (\n                OSError,\n                WebSocketError,\n                aiohttp.ClientError,\n                asyncio.TimeoutError,\n                ReconnectWebSocketError,\n            ),\n        ),\n        reraise=True,\n        before_sleep=before_sleep_log(_LOGGER, logging.DEBUG),\n    )\n    async def connect(self, *, reconnect: bool = True) -&gt; None:\n        \"\"\"Connect to the WebSocket API.\n\n        Warning:\n            No events will be dispatched until you subscribe to a receiver.\n            Typically, you should pass the `organization` attribute of a barrier\n            object to the `subscribe` method to start receiving data. Don't ask me\n            why `organization` specifically, I don't know either.\n\n        Danger:\n            This method will block the event loop until the connection is closed.\n            If you want to run this method in the background, you should run it in a\n            separate thread or process.\n\n        Args:\n            reconnect (bool): Whether to reconnect if the connection is lost.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ApiError: If an API error occurs.\n            WebSocketError: If an error occurs while connecting.\n        \"\"\"\n        try:\n            if self.id_token is None:\n                raise NoAuthError\n\n            if self._endpoints is None:\n                msg = \"Endpoints not available\"\n                raise ApiError(msg)\n\n            if self._session is None:\n                msg = \"ClientSession not provided\"\n                raise ValueError(msg)\n\n            self._reconnect = reconnect\n\n            device_url = self._endpoints[\"GraphQL\"][\"device\"][\"wss\"]\n            events_url = self._endpoints[\"GraphQL\"][\"events\"][\"wss\"]\n\n            _LOGGER.debug(\"Connecting to WebSocket API %s\", device_url)\n\n            self._device_ws = WebSocketClient(client_session=self._session)\n            await self._device_ws.connect(\n                self.id_token,\n                yarl.URL(device_url),\n                \"device\",\n                self._dispatch,\n                yarl.URL(self._endpoints[\"GraphQL\"][\"device\"][\"https\"]).host,\n            )\n            self._events_ws = WebSocketClient(client_session=self._session)\n            await self._events_ws.connect(\n                self.id_token,\n                yarl.URL(events_url),\n                \"events\",\n                self._dispatch,\n                yarl.URL(self._endpoints[\"GraphQL\"][\"events\"][\"https\"]).host,\n            )\n\n            _LOGGER.debug(\"Connected to WebSocket API\")\n\n            device_task = asyncio.create_task(self._poll_device_ws())\n            events_task = asyncio.create_task(self._poll_events_ws())\n\n            with contextlib.suppress(asyncio.CancelledError):\n                done, pending = await asyncio.wait(\n                    [device_task, events_task],\n                    return_when=asyncio.FIRST_EXCEPTION,\n                )\n\n            with contextlib.suppress(UnboundLocalError):\n                if exceptions := [\n                    task.exception() for task in done if task.exception()\n                ]:\n                    for p in pending:\n                        p.cancel()\n                    # Make sure both WS are closed\n                    await self._events_ws.close()\n                    await self._device_ws.close()\n                    raise exceptions[0]  # type: ignore[misc]\n        except (\n            OSError,\n            WebSocketError,\n            aiohttp.ClientError,\n            asyncio.TimeoutError,\n            ReconnectWebSocketError,\n        ) as e:\n            self._dispatch(\"connection_lost\", {\"exception\": e})\n            self._device_connected = False\n            self._events_connected = False\n            if not reconnect:\n                _LOGGER.debug(\"Connection lost, not reconnecting\")\n                await self.close()\n                raise\n\n            if self.closed:\n                return\n\n            _LOGGER.debug(\"Connection lost, retrying...\")\n\n            # Raising triggers retry\n            raise\n\n    async def subscribe(self, receiver: str) -&gt; list[str]:\n        \"\"\"Subscribe to a receiver.\n\n        Args:\n            receiver (str): The receiver to subscribe to.\n\n        Returns:\n            The subscription IDs. You can pass this into the `unsubscribe` method to\n                unsubscribe from the receiver.\n\n        Raises:\n            WebSocketError: If no WebSocket connection is available.\n        \"\"\"\n        if self._device_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n        if self._events_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n\n        _LOGGER.debug(\"Subscribing to receiver %s\", receiver)\n\n        return [\n            await self._device_ws.subscribe(receiver),\n            await self._events_ws.subscribe(receiver),\n        ]\n\n    async def unsubscribe(self, subscription_id: str) -&gt; None:\n        \"\"\"Unsubscribe from a receiver.\n\n        Args:\n            subscription_id (str): The subscription ID to unsubscribe from.\n\n        Raises:\n            WebSocketError: If no WebSocket connection is available\n        \"\"\"\n        if self._device_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n        if self._events_ws is None:\n            msg = \"No WebSocket connection\"\n            raise WebSocketError(msg)\n\n        _LOGGER.debug(\"Unsubscribing from subscription %s\", subscription_id)\n\n        await self._device_ws.unsubscribe(subscription_id)\n        await self._events_ws.unsubscribe(subscription_id)\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the connection.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n        \"\"\"\n\n        async def _close() -&gt; None:\n            if self._device_ws:\n                await self._device_ws.close()\n            if self._events_ws:\n                await self._events_ws.close()\n\n        _LOGGER.debug(\"Closing connection\")\n\n        self._closing_task = asyncio.create_task(_close())\n        await self._closing_task\n\n    async def get_all_barriers(self) -&gt; list[Barrier]:\n        \"\"\"Get all barriers.\n\n        Returns:\n            A list of all barriers.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Getting all barriers\")\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"get_all_barriers\", None),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Got all barriers\")\n        _LOGGER.debug(\"Data: %s\", data)\n\n        await self._check_response_errors(data)\n\n        barriers = []\n\n        for device in data[\"data\"][\"devicesListAll\"][\"devices\"]:\n            if device[\"state\"][\"connectionState\"] is not None:\n                connection_state = ConnectionState(\n                    device[\"state\"][\"connectionState\"][\"connected\"],\n                    device[\"state\"][\"connectionState\"][\"updatedTimestamp\"],\n                )\n            else:\n                connection_state = None\n            barrier_state = BarrierState(\n                device[\"state\"][\"deviceId\"],\n                json.loads(device[\"state\"][\"reported\"]),\n                device[\"state\"][\"timestamp\"],\n                device[\"state\"][\"version\"],\n                connection_state,\n            )\n            barrier = Barrier(\n                device[\"id\"],\n                device[\"type\"],\n                device[\"controlLevel\"],\n                device[\"attr\"],\n                barrier_state,\n                self,\n            )\n            barriers.append(barrier)\n\n        return barriers\n\n    async def open_barrier(self, barrier_id: str) -&gt; bool:\n        \"\"\"Open a barrier.\n\n        Args:\n            barrier_id (str): The ID of the barrier to open.\n\n        Returns:\n            Whether the barrier was opened successfully.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Opening barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"open_barrier\", {\"barrier_id\": barrier_id}),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Opening barrier response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def close_barrier(self, barrier_id: str) -&gt; bool:\n        \"\"\"Close a barrier.\n\n        Args:\n            barrier_id (str): The ID of the barrier to close.\n\n        Returns:\n            Whether the barrier was closed successfully.\"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Closing barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\n                \"close_barrier\",\n                {\"barrier_id\": barrier_id},\n            ),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Closing barrier response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def light_on(self, barrier_id: str) -&gt; bool:\n        \"\"\"Turn the light on.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn the light on.\n\n        Returns:\n            Whether the light was turned on successfully.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning light on for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"light_on\", {\"barrier_id\": barrier_id}),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Turning light on response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def light_off(self, barrier_id: str) -&gt; bool:\n        \"\"\"Turn the light off.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn the light off.\n\n        Returns:\n            Whether the light was turned off successfully.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning light off for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\"light_off\", {\"barrier_id\": barrier_id}),\n        )\n        data = await response.json()\n\n        _LOGGER.debug(\"Turning light off response: %s\", data)\n        await self._check_response_errors(data)\n\n        result: bool = data[\"data\"][\"devicesControl\"]\n\n        return result\n\n    async def vacation_mode_on(self, barrier_id: str) -&gt; None:\n        \"\"\"Turn vacation mode on.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn vacation mode on.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning vacation mode on for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\n                \"vacation_mode_on\",\n                {\"barrier_id\": barrier_id},\n            ),\n        )\n        await response.json()\n\n    async def vacation_mode_off(self, barrier_id: str) -&gt; None:\n        \"\"\"Turn vacation mode off.\n\n        Args:\n            barrier_id (str): The ID of the barrier to turn vacation mode off.\n\n        Raises:\n            NoAuthError: If the ID token is not available.\n            ValueError: If the ClientSession or Endpoints are not available.\n            ApiError: If an API error occurs.\n        \"\"\"\n        if self.id_token is None:\n            raise NoAuthError\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n        _LOGGER.debug(\"Turning vacation mode off for barrier %s\", barrier_id)\n        _LOGGER.debug(\"API URL: %s\", api_url)\n\n        headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n        response = await self._session.post(\n            api_url,\n            headers=headers,\n            json=await get_request_template(\n                \"vacation_mode_off\",\n                {\"barrier_id\": barrier_id},\n            ),\n        )\n        await response.json()\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.closed","title":"<code>closed: bool</code>  <code>property</code>","text":"<p>Check if the connection is closed.</p>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.__authenticate","title":"<code>__authenticate(user_name: str | None, password: str | None, refresh_token: str | None) -&gt; str | None</code>  <code>async</code>","text":"<p>Authenticate using username and password or refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str | None</code> <p>The username.</p> required <code>password</code> <code>str | None</code> <p>The password.</p> required <code>refresh_token</code> <code>str | None</code> <p>The refresh token.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The refresh token.</p> <p>Raises:</p> Type Description <code>AuthFailedError</code> <p>If the authentication fails.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def __authenticate(\n    self,\n    user_name: str | None,\n    password: str | None,\n    refresh_token: str | None,\n) -&gt; str | None:\n    \"\"\"Authenticate using username and password or refresh token.\n\n    Args:\n        user_name (str | None): The username.\n        password (str | None): The password.\n        refresh_token (str | None): The refresh token.\n\n    Returns:\n        The refresh token.\n\n    Raises:\n        AuthFailedError: If the authentication fails.\n        ApiError: If an API error occurs.\n    \"\"\"\n    try:\n        _LOGGER.debug(\"Authenticating\")\n\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n\n        # Get the endpoints\n        data = await self._session.get(ENDPOINTS_URL)\n        endpoints = await data.json()\n        self._endpoints = endpoints[\"endpoints\"]\n\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        authenticator = AwsCognitoAuthenticator(\n            self._endpoints[\"Config\"][\"Region\"],\n            self._endpoints[\"Config\"][\"ClientId\"],\n            self._endpoints[\"Config\"][\"UserPoolId\"],\n            self._endpoints[\"Config\"][\"IdentityPoolId\"],\n        )\n\n        if user_name and password:\n            token = await asyncio.to_thread(\n                authenticator.get_new_token,\n                user_name,\n                password,\n            )\n        elif refresh_token:\n            token = await asyncio.to_thread(\n                authenticator.refresh_token,\n                refresh_token,\n            )\n\n        _LOGGER.debug(\"Authenticated\")\n\n        self.id_token = token.id_token\n    except botocore.exceptions.ClientError as e:\n        _LOGGER.exception(\"Exception while authenticating\")\n        if e.response[\"Error\"][\"Code\"] == \"NotAuthorizedException\":\n            raise AuthFailedError from e\n        raise ApiError from e\n    else:\n        return token.refresh_token\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.__init__","title":"<code>__init__() -&gt; None</code>","text":"<p>Initialize the NiceGOApi object.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the NiceGOApi object.\"\"\"\n    self.id_token: str | None = None\n    self._closing_task: asyncio.Task[None] | None = None\n    self._device_ws: WebSocketClient | None = None\n    self._endpoints: dict[str, Any] | None = None\n    self._session: aiohttp.ClientSession | None = None\n    self._event_tasks: set[asyncio.Task[None]] = set()\n    self._events_ws: WebSocketClient | None = None\n    self._device_connected: bool = False\n    self._events_connected: bool = False\n    self._events: dict[str, list[Callable[..., Coroutine[Any, Any, Any]]]] = {}\n\n    self.event(self.on_device_connected)\n    self.event(self.on_events_connected)\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.authenticate","title":"<code>authenticate(user_name: str, password: str, session: aiohttp.ClientSession) -&gt; str | None</code>  <code>async</code>","text":"<p>Authenticate using username and password.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>str</code> <p>The username.</p> required <code>password</code> <code>str</code> <p>The password.</p> required <code>session</code> <code>ClientSession</code> <p>The client session to use.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The refresh token.</p> <p>Raises:</p> Type Description <code>AuthFailedError</code> <p>If the authentication fails.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def authenticate(\n    self,\n    user_name: str,\n    password: str,\n    session: aiohttp.ClientSession,\n) -&gt; str | None:\n    \"\"\"Authenticate using username and password.\n\n    Args:\n        user_name (str): The username.\n        password (str): The password.\n        session (aiohttp.ClientSession): The client session to use.\n\n    Returns:\n        The refresh token.\n\n    Raises:\n        AuthFailedError: If the authentication fails.\n        ApiError: If an API error occurs.\n    \"\"\"\n    self._session = session\n    return await self.__authenticate(user_name, password, None)\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.authenticate_refresh","title":"<code>authenticate_refresh(refresh_token: str, session: aiohttp.ClientSession) -&gt; None</code>  <code>async</code>","text":"<p>Authenticate using a previous obtained refresh token.</p> <p>Parameters:</p> Name Type Description Default <code>refresh_token</code> <code>str</code> <p>The refresh token.</p> required <code>session</code> <code>ClientSession</code> <p>The client session to use.</p> required <p>Raises:</p> Type Description <code>AuthFailedError</code> <p>If the authentication fails.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def authenticate_refresh(\n    self,\n    refresh_token: str,\n    session: aiohttp.ClientSession,\n) -&gt; None:\n    \"\"\"Authenticate using a previous obtained refresh token.\n\n    Args:\n        refresh_token (str): The refresh token.\n        session (aiohttp.ClientSession): The client session to use.\n\n    Raises:\n        AuthFailedError: If the authentication fails.\n        ApiError: If an API error occurs.\n    \"\"\"\n    self._session = session\n    await self.__authenticate(None, None, refresh_token)\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.close","title":"<code>close() -&gt; None</code>  <code>async</code>","text":"<p>Close the connection.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the connection.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n    \"\"\"\n\n    async def _close() -&gt; None:\n        if self._device_ws:\n            await self._device_ws.close()\n        if self._events_ws:\n            await self._events_ws.close()\n\n    _LOGGER.debug(\"Closing connection\")\n\n    self._closing_task = asyncio.create_task(_close())\n    await self._closing_task\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.close_barrier","title":"<code>close_barrier(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Close a barrier.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to close.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the barrier was closed successfully.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def close_barrier(self, barrier_id: str) -&gt; bool:\n    \"\"\"Close a barrier.\n\n    Args:\n        barrier_id (str): The ID of the barrier to close.\n\n    Returns:\n        Whether the barrier was closed successfully.\"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Closing barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\n            \"close_barrier\",\n            {\"barrier_id\": barrier_id},\n        ),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Closing barrier response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.connect","title":"<code>connect(*, reconnect: bool = True) -&gt; None</code>  <code>async</code>","text":"<p>Connect to the WebSocket API.</p> Warning <p>No events will be dispatched until you subscribe to a receiver. Typically, you should pass the <code>organization</code> attribute of a barrier object to the <code>subscribe</code> method to start receiving data. Don't ask me why <code>organization</code> specifically, I don't know either.</p> Danger <p>This method will block the event loop until the connection is closed. If you want to run this method in the background, you should run it in a separate thread or process.</p> <p>Parameters:</p> Name Type Description Default <code>reconnect</code> <code>bool</code> <p>Whether to reconnect if the connection is lost.</p> <code>True</code> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> <code>WebSocketError</code> <p>If an error occurs while connecting.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>@retry(\n    wait=wait_random_exponential(multiplier=1, min=1, max=10),\n    retry=_RetryIfReconnect()\n    &amp; retry_if_exception_type(\n        (\n            OSError,\n            WebSocketError,\n            aiohttp.ClientError,\n            asyncio.TimeoutError,\n            ReconnectWebSocketError,\n        ),\n    ),\n    reraise=True,\n    before_sleep=before_sleep_log(_LOGGER, logging.DEBUG),\n)\nasync def connect(self, *, reconnect: bool = True) -&gt; None:\n    \"\"\"Connect to the WebSocket API.\n\n    Warning:\n        No events will be dispatched until you subscribe to a receiver.\n        Typically, you should pass the `organization` attribute of a barrier\n        object to the `subscribe` method to start receiving data. Don't ask me\n        why `organization` specifically, I don't know either.\n\n    Danger:\n        This method will block the event loop until the connection is closed.\n        If you want to run this method in the background, you should run it in a\n        separate thread or process.\n\n    Args:\n        reconnect (bool): Whether to reconnect if the connection is lost.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ApiError: If an API error occurs.\n        WebSocketError: If an error occurs while connecting.\n    \"\"\"\n    try:\n        if self.id_token is None:\n            raise NoAuthError\n\n        if self._endpoints is None:\n            msg = \"Endpoints not available\"\n            raise ApiError(msg)\n\n        if self._session is None:\n            msg = \"ClientSession not provided\"\n            raise ValueError(msg)\n\n        self._reconnect = reconnect\n\n        device_url = self._endpoints[\"GraphQL\"][\"device\"][\"wss\"]\n        events_url = self._endpoints[\"GraphQL\"][\"events\"][\"wss\"]\n\n        _LOGGER.debug(\"Connecting to WebSocket API %s\", device_url)\n\n        self._device_ws = WebSocketClient(client_session=self._session)\n        await self._device_ws.connect(\n            self.id_token,\n            yarl.URL(device_url),\n            \"device\",\n            self._dispatch,\n            yarl.URL(self._endpoints[\"GraphQL\"][\"device\"][\"https\"]).host,\n        )\n        self._events_ws = WebSocketClient(client_session=self._session)\n        await self._events_ws.connect(\n            self.id_token,\n            yarl.URL(events_url),\n            \"events\",\n            self._dispatch,\n            yarl.URL(self._endpoints[\"GraphQL\"][\"events\"][\"https\"]).host,\n        )\n\n        _LOGGER.debug(\"Connected to WebSocket API\")\n\n        device_task = asyncio.create_task(self._poll_device_ws())\n        events_task = asyncio.create_task(self._poll_events_ws())\n\n        with contextlib.suppress(asyncio.CancelledError):\n            done, pending = await asyncio.wait(\n                [device_task, events_task],\n                return_when=asyncio.FIRST_EXCEPTION,\n            )\n\n        with contextlib.suppress(UnboundLocalError):\n            if exceptions := [\n                task.exception() for task in done if task.exception()\n            ]:\n                for p in pending:\n                    p.cancel()\n                # Make sure both WS are closed\n                await self._events_ws.close()\n                await self._device_ws.close()\n                raise exceptions[0]  # type: ignore[misc]\n    except (\n        OSError,\n        WebSocketError,\n        aiohttp.ClientError,\n        asyncio.TimeoutError,\n        ReconnectWebSocketError,\n    ) as e:\n        self._dispatch(\"connection_lost\", {\"exception\": e})\n        self._device_connected = False\n        self._events_connected = False\n        if not reconnect:\n            _LOGGER.debug(\"Connection lost, not reconnecting\")\n            await self.close()\n            raise\n\n        if self.closed:\n            return\n\n        _LOGGER.debug(\"Connection lost, retrying...\")\n\n        # Raising triggers retry\n        raise\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.event","title":"<code>event(coro: CoroT) -&gt; CoroT</code>","text":"<p>Decorator to add an event listener. Just a wrapper around <code>listen</code>.</p> Info <p>This can only decorate coroutine functions.</p> <p>Parameters:</p> Name Type Description Default <code>coro</code> <code>CoroT</code> <p>The coroutine function to decorate.</p> required <p>Examples:</p> <p>You can use this decorator to add event listeners to the API object. Some events include but are not limited to:</p> <ul> <li><code>connection_lost</code>: Triggered when the connection to the WebSocket API is     lost.</li> <li><code>connected</code>: Triggered when the connection to the WebSocket API is     established.</li> <li><code>data</code>: Triggered when data is received from an active subscription.     See <code>subscribe</code>.</li> </ul> <pre><code>&gt;&gt;&gt; @api.event\n... async def on_data(\n...     data: dict[str, Any] | None = None,\n... ) -&gt; None:\n...     if data is not None:\n...         print(data)\n</code></pre> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>def event(self, coro: CoroT) -&gt; CoroT:\n    \"\"\"Decorator to add an event listener. Just a wrapper around `listen`.\n\n    Info:\n        This can only decorate coroutine functions.\n\n    Args:\n        coro (CoroT): The coroutine function to decorate.\n\n    Examples:\n        You can use this decorator to add event listeners to the API object.\n        Some events include but are not limited to:\n\n        - `connection_lost`: Triggered when the connection to the WebSocket API is\n            lost.\n        - `connected`: Triggered when the connection to the WebSocket API is\n            established.\n        - `data`: Triggered when data is received from an active subscription.\n            See `subscribe`.\n\n        &gt;&gt;&gt; @api.event\n        ... async def on_data(\n        ...     data: dict[str, Any] | None = None,\n        ... ) -&gt; None:\n        ...     if data is not None:\n        ...         print(data)\n    \"\"\"\n    self.listen(coro.__name__, coro)\n    return coro\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.get_all_barriers","title":"<code>get_all_barriers() -&gt; list[Barrier]</code>  <code>async</code>","text":"<p>Get all barriers.</p> <p>Returns:</p> Type Description <code>list[Barrier]</code> <p>A list of all barriers.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def get_all_barriers(self) -&gt; list[Barrier]:\n    \"\"\"Get all barriers.\n\n    Returns:\n        A list of all barriers.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Getting all barriers\")\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"get_all_barriers\", None),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Got all barriers\")\n    _LOGGER.debug(\"Data: %s\", data)\n\n    await self._check_response_errors(data)\n\n    barriers = []\n\n    for device in data[\"data\"][\"devicesListAll\"][\"devices\"]:\n        if device[\"state\"][\"connectionState\"] is not None:\n            connection_state = ConnectionState(\n                device[\"state\"][\"connectionState\"][\"connected\"],\n                device[\"state\"][\"connectionState\"][\"updatedTimestamp\"],\n            )\n        else:\n            connection_state = None\n        barrier_state = BarrierState(\n            device[\"state\"][\"deviceId\"],\n            json.loads(device[\"state\"][\"reported\"]),\n            device[\"state\"][\"timestamp\"],\n            device[\"state\"][\"version\"],\n            connection_state,\n        )\n        barrier = Barrier(\n            device[\"id\"],\n            device[\"type\"],\n            device[\"controlLevel\"],\n            device[\"attr\"],\n            barrier_state,\n            self,\n        )\n        barriers.append(barrier)\n\n    return barriers\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.light_off","title":"<code>light_off(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Turn the light off.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn the light off.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the light was turned off successfully.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def light_off(self, barrier_id: str) -&gt; bool:\n    \"\"\"Turn the light off.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn the light off.\n\n    Returns:\n        Whether the light was turned off successfully.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning light off for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"light_off\", {\"barrier_id\": barrier_id}),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Turning light off response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.light_on","title":"<code>light_on(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Turn the light on.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn the light on.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the light was turned on successfully.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def light_on(self, barrier_id: str) -&gt; bool:\n    \"\"\"Turn the light on.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn the light on.\n\n    Returns:\n        Whether the light was turned on successfully.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning light on for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"light_on\", {\"barrier_id\": barrier_id}),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Turning light on response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.listen","title":"<code>listen(event_name: str, coro: CoroT) -&gt; Callable[[], None]</code>","text":"<p>Add an event listener.</p> <p>Parameters:</p> Name Type Description Default <code>event_name</code> <code>str</code> <p>The name of the event.</p> required <code>coro</code> <code>CoroT</code> <p>The coroutine to run when the event is dispatched.</p> required <p>Returns:</p> Type Description <code>Callable[[], None]</code> <p>A function to remove the event listener.</p> <p>Examples:</p> <p>You can use this method to add event listeners to the API object. Some events include but are not limited to:</p> <ul> <li><code>connection_lost</code>: Triggered when the connection to the WebSocket API is     lost.</li> <li><code>connected</code>: Triggered when the connection to the WebSocket API is     established.</li> <li><code>data</code>: Triggered when data is received from an active subscription.     See <code>subscribe</code>.</li> </ul> <pre><code>&gt;&gt;&gt; def on_data(data: dict[str, Any] | None = None) -&gt; None:\n...     if data is not None:\n...         print(data)\n...\n&gt;&gt;&gt; remove_listener = api.listen(\"data\", on_data)\n</code></pre> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>def listen(self, event_name: str, coro: CoroT) -&gt; Callable[[], None]:\n    \"\"\"Add an event listener.\n\n    Args:\n        event_name (str): The name of the event.\n        coro (CoroT): The coroutine to run when the event is dispatched.\n\n    Returns:\n        A function to remove the event listener.\n\n    Examples:\n        You can use this method to add event listeners to the API object.\n        Some events include but are not limited to:\n\n        - `connection_lost`: Triggered when the connection to the WebSocket API is\n            lost.\n        - `connected`: Triggered when the connection to the WebSocket API is\n            established.\n        - `data`: Triggered when data is received from an active subscription.\n            See `subscribe`.\n\n        &gt;&gt;&gt; def on_data(data: dict[str, Any] | None = None) -&gt; None:\n        ...     if data is not None:\n        ...         print(data)\n        ...\n        &gt;&gt;&gt; remove_listener = api.listen(\"data\", on_data)\n    \"\"\"\n    if not asyncio.iscoroutinefunction(coro):\n        msg = \"The decorated function must be a coroutine\"\n        raise TypeError(msg)\n\n    _LOGGER.debug(\"Adding event listener %s\", coro.__name__)\n\n    self._events.setdefault(event_name, []).append(coro)\n    return lambda: self._events[event_name].remove(coro)\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.on_device_connected","title":"<code>on_device_connected() -&gt; None</code>  <code>async</code>","text":"<p>Handle the device connected event.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def on_device_connected(self) -&gt; None:\n    \"\"\"Handle the device connected event.\"\"\"\n    self._device_connected = True\n    if self._device_connected and self._events_connected:\n        # Only dispatch when both feeds are connected\n        self._dispatch(\"connected\")\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.on_events_connected","title":"<code>on_events_connected() -&gt; None</code>  <code>async</code>","text":"<p>Handle the events connected event.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def on_events_connected(self) -&gt; None:\n    \"\"\"Handle the events connected event.\"\"\"\n    self._events_connected = True\n    if self._device_connected and self._events_connected:\n        # Only dispatch when both feeds are connected\n        self._dispatch(\"connected\")\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.open_barrier","title":"<code>open_barrier(barrier_id: str) -&gt; bool</code>  <code>async</code>","text":"<p>Open a barrier.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to open.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the barrier was opened successfully.</p> <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def open_barrier(self, barrier_id: str) -&gt; bool:\n    \"\"\"Open a barrier.\n\n    Args:\n        barrier_id (str): The ID of the barrier to open.\n\n    Returns:\n        Whether the barrier was opened successfully.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Opening barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\"open_barrier\", {\"barrier_id\": barrier_id}),\n    )\n    data = await response.json()\n\n    _LOGGER.debug(\"Opening barrier response: %s\", data)\n    await self._check_response_errors(data)\n\n    result: bool = data[\"data\"][\"devicesControl\"]\n\n    return result\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.subscribe","title":"<code>subscribe(receiver: str) -&gt; list[str]</code>  <code>async</code>","text":"<p>Subscribe to a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str</code> <p>The receiver to subscribe to.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The subscription IDs. You can pass this into the <code>unsubscribe</code> method to unsubscribe from the receiver.</p> <p>Raises:</p> Type Description <code>WebSocketError</code> <p>If no WebSocket connection is available.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def subscribe(self, receiver: str) -&gt; list[str]:\n    \"\"\"Subscribe to a receiver.\n\n    Args:\n        receiver (str): The receiver to subscribe to.\n\n    Returns:\n        The subscription IDs. You can pass this into the `unsubscribe` method to\n            unsubscribe from the receiver.\n\n    Raises:\n        WebSocketError: If no WebSocket connection is available.\n    \"\"\"\n    if self._device_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n    if self._events_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n\n    _LOGGER.debug(\"Subscribing to receiver %s\", receiver)\n\n    return [\n        await self._device_ws.subscribe(receiver),\n        await self._events_ws.subscribe(receiver),\n    ]\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.unsubscribe","title":"<code>unsubscribe(subscription_id: str) -&gt; None</code>  <code>async</code>","text":"<p>Unsubscribe from a receiver.</p> <p>Parameters:</p> Name Type Description Default <code>subscription_id</code> <code>str</code> <p>The subscription ID to unsubscribe from.</p> required <p>Raises:</p> Type Description <code>WebSocketError</code> <p>If no WebSocket connection is available</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def unsubscribe(self, subscription_id: str) -&gt; None:\n    \"\"\"Unsubscribe from a receiver.\n\n    Args:\n        subscription_id (str): The subscription ID to unsubscribe from.\n\n    Raises:\n        WebSocketError: If no WebSocket connection is available\n    \"\"\"\n    if self._device_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n    if self._events_ws is None:\n        msg = \"No WebSocket connection\"\n        raise WebSocketError(msg)\n\n    _LOGGER.debug(\"Unsubscribing from subscription %s\", subscription_id)\n\n    await self._device_ws.unsubscribe(subscription_id)\n    await self._events_ws.unsubscribe(subscription_id)\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.vacation_mode_off","title":"<code>vacation_mode_off(barrier_id: str) -&gt; None</code>  <code>async</code>","text":"<p>Turn vacation mode off.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn vacation mode off.</p> required <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def vacation_mode_off(self, barrier_id: str) -&gt; None:\n    \"\"\"Turn vacation mode off.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn vacation mode off.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning vacation mode off for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\n            \"vacation_mode_off\",\n            {\"barrier_id\": barrier_id},\n        ),\n    )\n    await response.json()\n</code></pre>"},{"location":"api_docs/#nice_go.nice_go_api.NiceGOApi.vacation_mode_on","title":"<code>vacation_mode_on(barrier_id: str) -&gt; None</code>  <code>async</code>","text":"<p>Turn vacation mode on.</p> <p>Parameters:</p> Name Type Description Default <code>barrier_id</code> <code>str</code> <p>The ID of the barrier to turn vacation mode on.</p> required <p>Raises:</p> Type Description <code>NoAuthError</code> <p>If the ID token is not available.</p> <code>ValueError</code> <p>If the ClientSession or Endpoints are not available.</p> <code>ApiError</code> <p>If an API error occurs.</p> Source code in <code>src/nice_go/nice_go_api.py</code> <pre><code>async def vacation_mode_on(self, barrier_id: str) -&gt; None:\n    \"\"\"Turn vacation mode on.\n\n    Args:\n        barrier_id (str): The ID of the barrier to turn vacation mode on.\n\n    Raises:\n        NoAuthError: If the ID token is not available.\n        ValueError: If the ClientSession or Endpoints are not available.\n        ApiError: If an API error occurs.\n    \"\"\"\n    if self.id_token is None:\n        raise NoAuthError\n    if self._session is None:\n        msg = \"ClientSession not provided\"\n        raise ValueError(msg)\n    if self._endpoints is None:\n        msg = \"Endpoints not available\"\n        raise ApiError(msg)\n\n    api_url = self._endpoints[\"GraphQL\"][\"device\"][\"https\"]\n\n    _LOGGER.debug(\"Turning vacation mode on for barrier %s\", barrier_id)\n    _LOGGER.debug(\"API URL: %s\", api_url)\n\n    headers = {\"Authorization\": self.id_token, \"Content-Type\": \"application/json\"}\n\n    response = await self._session.post(\n        api_url,\n        headers=headers,\n        json=await get_request_template(\n            \"vacation_mode_on\",\n            {\"barrier_id\": barrier_id},\n        ),\n    )\n    await response.json()\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#101-2025-01-26","title":"1.0.1 - 2025-01-26","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Added more exception handling</li> </ul>"},{"location":"changelog/#100-2024-12-14","title":"1.0.0 - 2024-12-14","text":""},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed <code>desired</code> from <code>BarrierState</code> since it's useless</li> </ul>"},{"location":"changelog/#0310-2024-11-08","title":"0.3.10 - 2024-11-08","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Increased receive timeout for WS polling</li> <li>Added extra debug logging to connection_ack check</li> </ul>"},{"location":"changelog/#039-2024-09-21","title":"0.3.9 - 2024-09-21","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added more debug logging</li> </ul>"},{"location":"changelog/#038-2024-08-30","title":"0.3.8 - 2024-08-30","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Loosen tenacity pin</li> </ul>"},{"location":"changelog/#037-2024-08-29","title":"0.3.7 - 2024-08-29","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Downgrade <code>tenacity</code> to 8.5.0, fixes dep conflict in HA</li> </ul>"},{"location":"changelog/#036-2024-08-29","title":"0.3.6 - 2024-08-29","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Switch to <code>tenacity</code> for retrying, should be completely backwards compatible</li> </ul>"},{"location":"changelog/#035-2024-08-26","title":"0.3.5 - 2024-08-26","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>More fixes (see commit history)</li> </ul>"},{"location":"changelog/#034-2024-08-26","title":"0.3.4 - 2024-08-26","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Try to prevent more errors</li> </ul>"},{"location":"changelog/#033-2024-08-26","title":"0.3.3 - 2024-08-26","text":""},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Try to prevent 'Task exception was never retrieved' (again)</li> </ul>"},{"location":"changelog/#032-2024-08-26","title":"0.3.2 - 2024-08-26","text":""},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Try to prevent 'Task exception was never retrieved'</li> </ul>"},{"location":"changelog/#031-2024-08-25","title":"0.3.1 - 2024-08-25","text":""},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Fixed reconnection logic</li> <li>Detects no keepalive</li> </ul>"},{"location":"changelog/#030-2024-08-19","title":"0.3.0 - 2024-08-19","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Add listen function</li> </ul>"},{"location":"changelog/#021-2024-08-19","title":"0.2.1 - 2024-08-19","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Allow multiple events to be added</li> </ul>"},{"location":"changelog/#020-2024-08-19","title":"0.2.0 - 2024-08-19","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Vacation mode support</li> <li>Barrier obstruction support</li> </ul>"},{"location":"changelog/#016-2024-08-01","title":"0.1.6 - 2024-08-01","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Add extra debug logging</li> </ul>"},{"location":"changelog/#015-2024-07-30","title":"0.1.5 - 2024-07-30","text":""},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Reverted unpin <code>pycognito</code></li> <li>Moved type stubs to dev dependencies</li> </ul>"},{"location":"changelog/#014-2024-07-29","title":"0.1.4 - 2024-07-29","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Last resort: unpinning <code>pycognito</code></li> </ul>"},{"location":"changelog/#013-2024-07-29","title":"0.1.3 - 2024-07-29","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Made <code>boto3</code> pinned version, hopefully fixing dep conflict in HA</li> </ul>"},{"location":"changelog/#012-2024-07-28","title":"0.1.2 - 2024-07-28","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Made all barrier commands public</li> </ul>"},{"location":"changelog/#011-2024-07-25","title":"0.1.1 - 2024-07-25","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Made BarrierState and ConnectionState public</li> </ul>"},{"location":"changelog/#010-2024-07-25","title":"0.1.0 - 2024-07-25","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Initial release!</li> </ul>"}]}